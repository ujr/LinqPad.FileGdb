using System.IO;
using System.Text;
using FileGDB.Core.WKT;
using Xunit;

namespace FileGDB.Core.Test;

public class ShapeBufferTest
{
	[Fact]
	public void CanEmptyPointBuffer()
	{
		var bytes = GetBytesPointEmpty();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(20, buffer.Bytes.Count);
		Assert.Equal(ShapeType.GeneralPoint, buffer.ShapeType);
		Assert.Equal(GeometryType.Point, buffer.GeometryType);
		Assert.False(buffer.HasZ);
		Assert.False(buffer.HasM);
		Assert.False(buffer.HasID);
		Assert.False(buffer.MayHaveCurves);
		Assert.True(buffer.IsEmpty);
		Assert.Equal(1, buffer.NumPoints); // sic
		Assert.Equal(1, buffer.NumParts); // sic
		Assert.Equal(0, buffer.NumCurves);
		Assert.Equal("POINT EMPTY", buffer.ToWKT());
		buffer.QueryCoords(0, out var x, out var y, out var z, out var m, out int id);
		Assert.True(double.IsNaN(x));
		Assert.True(double.IsNaN(y));
		Assert.Equal(0.0, z);
		Assert.True(double.IsNaN(m));
		Assert.Equal(0, id);
	}

	[Fact]
	public void CanEmptyPointBufferZMID()
	{
		var bytes = GetBytesPointEmptyZMID();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(40, buffer.Bytes.Count);
		Assert.Equal(ShapeType.GeneralPoint, buffer.ShapeType);
		Assert.Equal(GeometryType.Point, buffer.GeometryType);
		Assert.True(buffer.HasZ);
		Assert.True(buffer.HasM);
		Assert.True(buffer.HasID);
		Assert.False(buffer.MayHaveCurves);
		Assert.True(buffer.IsEmpty);
		Assert.Equal(1, buffer.NumPoints); // sic
		Assert.Equal(1, buffer.NumParts); // sic
		Assert.Equal(0, buffer.NumCurves);
		Assert.Equal("POINT ZM EMPTY", buffer.ToWKT());
		buffer.QueryCoords(0, out var x, out var y, out var z, out var m, out int id);
		Assert.True(double.IsNaN(x));
		Assert.True(double.IsNaN(y));
		Assert.Equal(0.0, z);
		Assert.True(double.IsNaN(m));
		Assert.Equal(0, id);
	}

	[Fact]
	public void CanPolylineZMID()
	{
		var bytes = GetBytesPolylineZM1();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(296, buffer.Bytes.Count);
		Assert.Equal(ShapeType.GeneralPolyline, buffer.ShapeType);
		Assert.Equal(GeometryType.Polyline, buffer.GeometryType);
		Assert.True(buffer.HasZ);
		Assert.True(buffer.HasM);
		Assert.True(buffer.HasID);
		Assert.False(buffer.MayHaveCurves); // this shape does not have the Curves flag
		Assert.False(buffer.IsEmpty);
		Assert.Equal(6, buffer.NumPoints);
		Assert.Equal(1, buffer.NumParts);
		Assert.Equal(0, buffer.NumCurves);
		Assert.Equal(
			"MULTILINESTRING ZM ((2652556.4 1223107.7 0 NaN, 2652715.2 1223240.0 -12 NaN, 2652691.3 1223110.3 403 NaN, 2652852.7 1223247.9 404 NaN, 2652799.8 1223105.1 405 NaN, 2652979.7 1223237.3 0 NaN))",
			buffer.ToWKT(1));
	}

	[Fact]
	public void CanPolylineZMCurves()
	{
		var bytes = GetBytesPolylineZM2();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(280, buffer.Bytes.Count);
		Assert.Equal(ShapeType.GeneralPolyline, buffer.ShapeType);
		Assert.Equal(GeometryType.Polyline, buffer.GeometryType);
		Assert.True(buffer.HasZ);
		Assert.True(buffer.HasM);
		Assert.False(buffer.HasID);
		Assert.True(buffer.MayHaveCurves); // this shape has the Curves flag
		Assert.False(buffer.IsEmpty);
		Assert.Equal(4, buffer.NumPoints);
		Assert.Equal(1, buffer.NumParts);
		Assert.Equal(2, buffer.NumCurves);
		// The curves (i.e., segment modifiers) don't show up in the WKT:
		Assert.Equal(
			"MULTILINESTRING ZM ((2652360.6 1222880.2 0 NaN, 2652564.3 1223025.7 0 NaN, 2652807.8 1223009.8 0 NaN, 2652982.4 1222888.1 0 NaN))",
			buffer.ToWKT(1));
	}

	[Fact]
	public void CanPointBuffer()
	{
		var bytes = GetBytesPointXY();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(20, buffer.Bytes.Count);
		Assert.Equal(ShapeType.GeneralPoint, buffer.ShapeType);
		Assert.Equal(GeometryType.Point, buffer.GeometryType);
		Assert.False(buffer.HasZ);
		Assert.False(buffer.HasM);
		Assert.False(buffer.HasID);
		Assert.False(buffer.IsEmpty);
		Assert.Equal(1, buffer.NumPoints);
		Assert.Equal(1, buffer.NumParts);
		Assert.Equal(0, buffer.NumCurves);
		Assert.Equal("POINT (2696602.9 1233151.7)", buffer.ToWKT(1));
		buffer.QueryCoords(0, out double x, out double y, out double z, out double m, out int id);
		Assert.Equal(2696602.9, x, 1);
		Assert.Equal(1233151.7, y, 1);
		Assert.Equal(0.0, z);
		Assert.True(double.IsNaN(m));
		Assert.Equal(0, id);
	}

	[Fact]
	public void CanMultipointID()
	{
		var bytes = GetBytesMultipointID();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(180, buffer.Bytes.Count);
		Assert.Equal(ShapeType.GeneralMultipoint, buffer.ShapeType);
		Assert.Equal(GeometryType.Multipoint, buffer.GeometryType);
		Assert.False(buffer.HasZ);
		Assert.False(buffer.HasM);
		Assert.True(buffer.HasID);
		Assert.False(buffer.IsEmpty);
		Assert.Equal(7, buffer.NumPoints);
		Assert.Equal(7, buffer.NumParts);
		Assert.Equal(0, buffer.NumCurves);
		Assert.Equal(
			"MULTIPOINT ((2652527.3 1222814.0), (2652680.8 1222851.0), (2652794.5 1222795.5), (2652691.3 1222713.5), (2652466.5 1222583.8), (2652559.1 1222697.6), (2652657.0 1222538.8))",
			buffer.ToWKT(1));
		int id;
		buffer.QueryCoords(2, out _, out _, out _, out _, out id);
		Assert.Equal(1, id);
		buffer.QueryCoords(3, out _, out _, out _, out _, out id);
		Assert.Equal(1, id);
		buffer.QueryCoords(5, out _, out _, out _, out _, out id);
		Assert.Equal(1, id);
	}

	[Fact]
	public void CanToWKT()
	{
		// Just test that all overloads yield the same result.
		// The underlying WKT writer has its own unit tests elsewhere.

		var bytes = GetBytesPointXY();
		var buffer = new ShapeBuffer(bytes);

		Assert.Equal(20, buffer.Bytes.Count);

		const string expected = "POINT (2696602.9 1233151.7)";

		string s = buffer.ToWKT(1);
		Assert.Equal(expected, s);

		var sb = new StringBuilder();
		buffer.ToWKT(sb, 1);
		Assert.Equal(expected, sb.ToString());

		var tw = new StringWriter();
		buffer.ToWKT(tw, 1);
		Assert.Equal(expected, tw.ToString());
	}

	#region Shape Buffers (produced with Geometry.ToEsriShape() by ArcGIS Pro 3.3)

	private static byte[] GetBytesPointEmpty()
	{
		// Empty point XY (no Z, no M, no ID) (both X and Y are NaN)
		return new byte[]
		{
			0x34, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF
		};
	}

	private static byte[] GetBytesPointEmptyZMID()
	{
		// Empty point XY Z M ID (X and Y must be NaN, Z is zero, M is NaN, ID is zero)
		return new byte[]
		{
			0x34,0x00,0x00,0xD0,
			0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,
			0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,
			0x00,0x00,0x00,0x00
		};
	}

	private static byte[] GetBytesPointXY()
	{
		// Point, XY, no Z, no M, no ID:
		return new byte[]
		{
			0x34, 0x00, 0x00, 0x00,
			0x08, 0xD7, 0xA3, 0x70, 0xCD, 0x92, 0x44, 0x41,
			0x80, 0x14, 0xAE, 0xAF, 0xFF, 0xD0, 0x32, 0x41
		};
	}

	private static byte[] GetBytesMultipointID()
	{
		// Multipoint, 7 points, ID set on vertices 2 3 5
		return new byte[]
		{
			0x35, 0x00, 0x00, 0x10,
			// xmin, ymin, xmax, ymax
			0x80, 0xD0, 0xB3, 0x39, 0x99, 0x3C, 0x44, 0x41,
			0xF0, 0x38, 0x45, 0xD7, 0x8A, 0xA7, 0x32, 0x41,
			0x90, 0x53, 0x74, 0x44, 0x3D, 0x3D, 0x44, 0x41,
			0x10, 0x3F, 0xC6, 0x0C, 0xC3, 0xA8, 0x32, 0x41,
			// NumPoints
			0x07, 0x00, 0x00, 0x00,
			// XY coords
			0x50, 0x84, 0x0D, 0xA7, 0xB7, 0x3C, 0x44, 0x41,
			0x70, 0xD7, 0x12, 0x02, 0x9E, 0xA8, 0x32, 0x41,
			0xF0, 0xEB, 0xC0, 0x61, 0x04, 0x3D, 0x44, 0x41,
			0x10, 0x3F, 0xC6, 0x0C, 0xC3, 0xA8, 0x32, 0x41,
			0x90, 0x53, 0x74, 0x44, 0x3D, 0x3D, 0x44, 0x41,
			0x60, 0xB1, 0xBF, 0x7C, 0x8B, 0xA8, 0x32, 0x41,
			0xF8, 0x7E, 0x6A, 0xAC, 0x09, 0x3D, 0x44, 0x41,
			0xD0, 0x6F, 0x5F, 0x77, 0x39, 0xA8, 0x32, 0x41,
			0x80, 0xD0, 0xB3, 0x39, 0x99, 0x3C, 0x44, 0x41,
			0x90, 0xA0, 0xF8, 0xD1, 0xB7, 0xA7, 0x32, 0x41,
			0x50, 0x84, 0x0D, 0x87, 0xC7, 0x3C, 0x44, 0x41,
			0x20, 0xE2, 0x58, 0x97, 0x29, 0xA8, 0x32, 0x41,
			0x10, 0xA5, 0xBD, 0x79, 0xF8, 0x3C, 0x44, 0x41,
			0xF0, 0x38, 0x45, 0xD7, 0x8A, 0xA7, 0x32, 0x41,
			// ID values
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00
		};
	}

	private static byte[] GetBytesPolylineZM1()
	{
		// Polyline ZMID, 1 part, 6 points, 5 line segments, M is always NaN
		return new byte[]
		{
			0x32, 0x00, 0x00, 0xD0,
			// xmin, ymin, xmax, ymax
			0x40, 0xF1, 0x63, 0x34, 0xC6, 0x3C, 0x44, 0x41,
			0xB0, 0x03, 0xE7, 0x0C, 0xC1, 0xA9, 0x32, 0x41,
			0x10, 0x02, 0x2B, 0xDF, 0x99, 0x3D, 0x44, 0x41,
			0xE0, 0xAC, 0xFA, 0xEC, 0x4F, 0xAA, 0x32, 0x41,
			// num parts
			0x01, 0x00, 0x00, 0x00,
			// num points
			0x06, 0x00, 0x00, 0x00,
			// part start indices
			0x00, 0x00, 0x00, 0x00,
			// XY coords
			0x40, 0xF1, 0x63, 0x34, 0xC6, 0x3C, 0x44, 0x41,
			0xC0, 0x29, 0x3A, 0xB2, 0xC3, 0xA9, 0x32, 0x41,
			0xD8, 0xC5, 0x6D, 0x94, 0x15, 0x3D, 0x44, 0x41,
			0x20, 0x1F, 0xF4, 0xFC, 0x47, 0xAA, 0x32, 0x41,
			0xF8, 0x7E, 0x6A, 0xAC, 0x09, 0x3D, 0x44, 0x41,
			0x90, 0xDD, 0x93, 0x57, 0xC6, 0xA9, 0x32, 0x41,
			0x78, 0x2D, 0x21, 0x5F, 0x5A, 0x3D, 0x44, 0x41,
			0xE0, 0xAC, 0xFA, 0xEC, 0x4F, 0xAA, 0x32, 0x41,
			0xA8, 0x79, 0xC7, 0xE9, 0x3F, 0x3D, 0x44, 0x41,
			0xB0, 0x03, 0xE7, 0x0C, 0xC1, 0xA9, 0x32, 0x41,
			0x10, 0x02, 0x2B, 0xDF, 0x99, 0x3D, 0x44, 0x41,
			0x10, 0xF9, 0xA0, 0x57, 0x45, 0xAA, 0x32, 0x41,
			// zmin, zmax, Z coords
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xC0,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x79, 0x40,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xC0,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x79, 0x40,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x79, 0x40,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x79, 0x40,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			// mmin, mmax, M coords
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			// ID values
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00
		};
	}

	private static byte[] GetBytesPolylineZM2()
	{
		// Polyline ZM, 1 part, 4 points, 3 segments: line, bezier, circular arc
		return new byte[]
		{
			0x32, 0x00, 0x00, 0xE0,
			// xmin,ymin,xmax,ymax
			0xD8, 0x68, 0x00, 0x4F, 0x64, 0x3C, 0x44, 0x41,
			0x38, 0x98, 0x69, 0xA2, 0xCC, 0xA8, 0x32, 0x41,
			0x18, 0x95, 0xD4, 0x31, 0x9B, 0x3D, 0x44, 0x41,
			0x66, 0xB7, 0xDC, 0xEE, 0xAA, 0xA9, 0x32, 0x41,
			// num parts
			0x01, 0x00, 0x00, 0x00,
			// num points
			0x04, 0x00, 0x00, 0x00,
			// part start indices
			0x00, 0x00, 0x00, 0x00,
			// XY coords
			0xD8, 0x68, 0x00, 0x4F, 0x64, 0x3C, 0x44, 0x41,
			0x00, 0x19, 0x73, 0x27, 0xE0, 0xA8, 0x32, 0x41,
			0x40, 0xF1, 0x63, 0x2C, 0xCA, 0x3C, 0x44, 0x41,
			0x40, 0xE8, 0xD9, 0xAC, 0x71, 0xA9, 0x32, 0x41,
			0xA8, 0x79, 0xC7, 0xE1, 0x43, 0x3D, 0x44, 0x41,
			0x40, 0xE8, 0xD9, 0xCC, 0x61, 0xA9, 0x32, 0x41,
			0x18, 0x95, 0xD4, 0x31, 0x9B, 0x3D, 0x44, 0x41,
			0x00, 0x19, 0x73, 0x17, 0xE8, 0xA8, 0x32, 0x41,
			// zmin, zmax, Z coords (all zero)
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			// mmin, mmax, M coords (all NaN)
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF,
			// num curves
			0x02, 0x00, 0x00, 0x00,
			// segment 1 modifier (Bezier)
			0x01, 0x00, 0x00, 0x00,
			0x04, 0x00, 0x00, 0x00,
			0x04, 0xCE, 0xD4, 0x22, 0x1B, 0x3D, 0x44, 0x41,
			0x95, 0x0F, 0x44, 0x14, 0x03, 0xA9, 0x32, 0x41,
			0x63, 0xBE, 0x4F, 0x6B, 0xB3, 0x3C, 0x44, 0x41,
			0x1F, 0x61, 0x9E, 0x87, 0x2D, 0xAA, 0x32, 0x41,
			// segment 2 modifier (elliptic (circular) arc)
			0x02, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00,
			0x85, 0x3D, 0x32, 0x9E, 0x57, 0x3D, 0x44, 0x41,
			0x3B, 0xF7, 0x0D, 0x4E, 0xE0, 0xA8, 0x32, 0x41,
			0x9E, 0x01, 0x00, 0x00
		};
	}

	#endregion
}
